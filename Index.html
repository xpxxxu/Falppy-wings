<!DOCTYPE html>
<html>
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird - Enhanced</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#87CEEB">
    <meta name="description" content="Enhanced Flappy Bird game with beautiful graphics and sound effects">
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIkZsYXBweSBCaXJkIC0gRW5oYW5jZWQiLAogICJzaG9ydF9uYW1lIjogIkZsYXBweSBCaXJkIiwKICAiZGVzY3JpcHRpb24iOiAiRW5oYW5jZWQgRmxhcHB5IEJpcmQgZ2FtZSB3aXRoIGJlYXV0aWZ1bCBncmFwaGljcyBhbmQgc291bmQgZWZmZWN0cyIsCiAgInN0YXJ0X3VybCI6ICIuLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzg3Q0VFQiIsCiAgInRoZW1lX2NvbG9yIjogIiM4N0NFRUIiLAogICJvcmllbnRhdGlvbiI6ICJwb3J0cmFpdCIsCiAgImljb25zIjogWwogICAgeyAic3JjIjogImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSUFBQUFDQUNBWUFBQUNIa0Jjb0FBQUFHWFJGVUhSVVMzUlRkWEkzUUhocFpTQkJZMnhoYkdoNVpuVmlBQm9nZFhScGJHbDBPQzR4VDFONmVXbFRNams0Wno0QUFBQUpjRWhaY3dBQURzUUFBQTdFQVpVcmdrc0FBQUJIQTU5VEc1amJXZGFWMEhoTWlCd1pYVndZWE1nYVdKc1FHOXNaWE53WXlBQUFBQUFCR0pGVWtKSlFnRUFBWXlHQUFBVTZOOUFBQUZFQUFBcFlXMUFBQUFqYUZKRVVqSkNNMjQ1V1ZGbE1FOWxZbWxXVG1kWVRXRkRNR0ZVVTFSWlpFODJTMWxKZERKNWJGa3pPSHBJWkE9PSIsICJzaXplcyI6ICIxOTJ4MTkyIiwgInR5cGUiOiAiaW1hZ2UvcG5nIiB9LAogICAgeyAic3JjIjogImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBU0FBQUFHZ0NBWUFBQUJrQTRGQ0FBQUFKWEpGVUhSVVMzUlRkWEkzUUhocFpTQkJZMnhoYkdoNVpuVmlBQm9nZFhScGJHbDBPQzR4VDFONmVXbFRNams0Wno0QUFBQUpjRWhaY3dBQURzUUFBQTdFQVpVcmdrc0FBQU04UFZSRFUzSmhkWEJsYVhSMVlUSlFkV2hhTkE9PSIsICJzaXplcyI6ICI1MTJ4NTEyIiwgInR5cGUiOiAiaW1hZ2UvcG5nIiB9CiAgXQp9">
    
    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEQgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAjGSURBVHgB7Z1NbBRVFIafc7MzOzulhSIgBBcmJCQkxoUJCYmJCxMSEhcmJCQkJiYkJCQkJCQkJCQkJiYkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJiYkJCQkLkxISEhcmJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQ=">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(180deg, #87CEEB 0%, #FFB6C1 50%, #98FB98 100%);
            font-family: 'Arial Black', Arial, sans-serif;
            touch-action: none;
            user-select: none;
            overflow: hidden;
        }
        canvas {
            border: 3px solid #2F4F4F;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            display: block;
            max-width: 100vw;
            max-height: 80vh;
            touch-action: none;
        }
        .game-container {
            text-align: center;
            position: relative;
        }
        .score {
            font-size: 28px;
            font-weight: bold;
            color: #FFF;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 10px;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            padding: 10px 20px;
            border-radius: 20px;
            display: inline-block;
        }
        .instructions {
            margin-top: 15px;
            color: #2F4F4F;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }
        .instructions p {
            margin: 5px 0;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="score">Score: <span id="score">0</span></div>
        <canvas id="gameCanvas" width="400" height="600"></canvas>
        <div class="instructions">
            <p>üê¶ Tap screen, press SPACE, or click to flap! üê¶</p>
            <p>Press R to restart after game over</p>
            <p>üîä Sound effects included!</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        // Audio Context for sound effects
        let audioContext;
        let soundEnabled = true;

        // Initialize audio context
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('Web Audio API not supported');
                soundEnabled = false;
            }
        }

        // Sound effect functions
        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!soundEnabled || !audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playFlapSound() {
            if (!soundEnabled) return;
            // Quick upward sweep for wing flap
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
            oscillator.type = 'triangle';
            
            gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        function playScoreSound() {
            if (!soundEnabled) return;
            // Cheerful ascending arpeggio
            const notes = [523, 659, 784, 1047]; // C, E, G, C
            notes.forEach((freq, i) => {
                setTimeout(() => playSound(freq, 0.2, 'triangle', 0.1), i * 50);
            });
        }

        function playGameOverSound() {
            if (!soundEnabled) return;
            // Dramatic descending sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.5);
            oscillator.type = 'sawtooth';
            
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        }

        function playHitSound() {
            if (!soundEnabled) return;
            // Sharp impact sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
            oscillator.type = 'square';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Game variables
        let gameState = 'playing';
        let score = 0;
        let frameCount = 0;
        let backgroundOffset = 0;
        let cloudOffset = 0;

        // Particle system for effects
        let particles = [];

        // Bird object with enhanced properties
        const bird = {
            x: 50,
            y: 300,
            width: 34,
            height: 28,
            velocity: 0,
            gravity: 0.5,
            jumpStrength: -9,
            rotation: 0,
            wingFrame: 0,
            wingSpeed: 0.3
        };

        // Pipes array
        let pipes = [];
        const pipeWidth = 52;
        const pipeGap = 160;
        const pipeSpeed = 2.5;

        // Clouds for background
        let clouds = [];

        // Ground with scrolling
        const ground = {
            height: 60,
            offset: 0
        };

        // Initialize clouds
        function initClouds() {
            clouds = [];
            for (let i = 0; i < 5; i++) {
                clouds.push({
                    x: Math.random() * canvas.width * 2,
                    y: Math.random() * 150 + 50,
                    size: Math.random() * 40 + 30,
                    speed: Math.random() * 0.5 + 0.2
                });
            }
        }

        // Create particle effect
        function createParticle(x, y, color) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 30,
                maxLife: 30,
                color: color,
                size: Math.random() * 4 + 2
            });
        }

        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2; // gravity
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Draw particles
        function drawParticles() {
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // Initialize game
        function init() {
            pipes = [];
            particles = [];
            bird.y = 300;
            bird.velocity = 0;
            bird.rotation = 0;
            score = 0;
            gameState = 'playing';
            frameCount = 0;
            backgroundOffset = 0;
            ground.offset = 0;
            updateScore();
            initClouds();
            initAudio();
            
            addPipe();
        }

        // Add new pipe with enhanced design
        function addPipe() {
            const minHeight = 80;
            const maxHeight = canvas.height - ground.height - pipeGap - minHeight;
            const topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
            
            pipes.push({
                x: canvas.width,
                topHeight: topHeight,
                bottomY: topHeight + pipeGap,
                bottomHeight: canvas.height - ground.height - (topHeight + pipeGap),
                passed: false,
                highlight: false
            });
        }

        // Update game state
        function update() {
            if (gameState !== 'playing') return;

            frameCount++;
            backgroundOffset -= 0.5;
            cloudOffset -= 0.3;
            ground.offset -= pipeSpeed;

            // Update bird animation and physics
            bird.wingFrame += bird.wingSpeed;
            bird.velocity += bird.gravity;
            bird.y += bird.velocity;
            
            // Bird rotation based on velocity
            bird.rotation = Math.min(Math.max(bird.velocity * 0.1, -0.5), 0.8);

            // Update clouds
            clouds.forEach(cloud => {
                cloud.x -= cloud.speed;
                if (cloud.x + cloud.size < 0) {
                    cloud.x = canvas.width + cloud.size;
                    cloud.y = Math.random() * 150 + 50;
                }
            });

            // Update pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= pipeSpeed;

                // Check if bird passed pipe
                if (!pipe.passed && pipe.x + pipeWidth < bird.x) {
                    pipe.passed = true;
                    pipe.highlight = true;
                    score++;
                    updateScore();
                    playScoreSound(); // Play score sound
                    
                    // Create score particles
                    for (let j = 0; j < 8; j++) {
                        createParticle(pipe.x + pipeWidth/2, pipe.topHeight + pipeGap/2, '#FFD700');
                    }
                    
                    setTimeout(() => pipe.highlight = false, 200);
                }

                // Remove pipes that are off screen
                if (pipe.x + pipeWidth < 0) {
                    pipes.splice(i, 1);
                }
            }

            // Add new pipe every 100 frames
            if (frameCount % 100 === 0) {
                addPipe();
            }

            // Update particles
            updateParticles();

            // Check collisions
            checkCollisions();
        }

        // Check for collisions
        function checkCollisions() {
            // Ground collision
            if (bird.y + bird.height >= canvas.height - ground.height) {
                playHitSound(); // Play hit sound
                gameOver();
                return;
            }

            // Ceiling collision
            if (bird.y <= 0) {
                playHitSound(); // Play hit sound
                gameOver();
                return;
            }

            // Pipe collisions
            for (const pipe of pipes) {
                if (bird.x < pipe.x + pipeWidth &&
                    bird.x + bird.width > pipe.x) {
                    
                    if (bird.y < pipe.topHeight || bird.y + bird.height > pipe.bottomY) {
                        playHitSound(); // Play hit sound
                        gameOver();
                        return;
                    }
                }
            }
        }

        // Game over with particle effect
        function gameOver() {
            gameState = 'gameOver';
            playGameOverSound(); // Play game over sound
            
            // Create explosion particles
            for (let i = 0; i < 15; i++) {
                createParticle(bird.x + bird.width/2, bird.y + bird.height/2, '#FF6B6B');
            }
        }

        // Bird jump with particle effect
        function jump() {
            if (gameState === 'playing') {
                bird.velocity = bird.jumpStrength;
                playFlapSound(); // Play flap sound
                
                // Create jump particles
                for (let i = 0; i < 5; i++) {
                    createParticle(bird.x, bird.y + bird.height, '#87CEEB');
                }
            }
        }

        // Update score display
        function updateScore() {
            scoreElement.textContent = score;
        }

        // Draw enhanced bird
        function drawBird() {
            ctx.save();
            ctx.translate(bird.x + bird.width/2, bird.y + bird.height/2);
            ctx.rotate(bird.rotation);
            
            // Bird body (gradient)
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, bird.width/2);
            gradient.addColorStop(0, '#FFD700');
            gradient.addColorStop(0.7, '#FFA500');
            gradient.addColorStop(1, '#FF8C00');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.ellipse(0, 0, bird.width/2, bird.height/2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Bird outline
            ctx.strokeStyle = '#B8860B';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Wing animation
            const wingOffset = Math.sin(bird.wingFrame) * 3;
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.ellipse(-5, wingOffset, 8, 12, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Eye
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(8, -5, 6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(10, -5, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Eye highlight
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(11, -6, 1, 0, Math.PI * 2);
            ctx.fill();
            
            // Beak
            ctx.fillStyle = '#FFA500';
            ctx.beginPath();
            ctx.moveTo(bird.width/2 - 2, -2);
            ctx.lineTo(bird.width/2 + 8, 0);
            ctx.lineTo(bird.width/2 - 2, 2);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }

        // Draw enhanced pipes
        function drawPipes() {
            pipes.forEach(pipe => {
                const glowColor = pipe.highlight ? '#FFD700' : '#228B22';
                
                if (pipe.highlight) {
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 20;
                }
                
                // Pipe gradient
                const gradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipeWidth, 0);
                gradient.addColorStop(0, '#32CD32');
                gradient.addColorStop(0.3, '#228B22');
                gradient.addColorStop(0.7, '#228B22');
                gradient.addColorStop(1, '#006400');
                
                ctx.fillStyle = gradient;
                
                // Top pipe
                ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
                // Bottom pipe  
                ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, pipe.bottomHeight);
                
                // Pipe caps with 3D effect
                const capGradient = ctx.createLinearGradient(pipe.x, 0, pipe.x + pipeWidth, 0);
                capGradient.addColorStop(0, '#90EE90');
                capGradient.addColorStop(0.5, '#32CD32');
                capGradient.addColorStop(1, '#228B22');
                
                ctx.fillStyle = capGradient;
                
                // Top cap
                ctx.fillRect(pipe.x - 4, pipe.topHeight - 25, pipeWidth + 8, 25);
                // Bottom cap
                ctx.fillRect(pipe.x - 4, pipe.bottomY, pipeWidth + 8, 25);
                
                // Pipe highlights
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(pipe.x + 2, 0, 3, pipe.topHeight);
                ctx.fillRect(pipe.x + 2, pipe.bottomY, 3, pipe.bottomHeight);
                
                ctx.shadowBlur = 0;
            });
        }

        // Draw animated background
        function drawBackground() {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(0.4, '#ADD8E6');
            skyGradient.addColorStop(0.8, '#90EE90');
            skyGradient.addColorStop(1, '#98FB98');
            
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height - ground.height);
            
            // Draw clouds
            clouds.forEach(cloud => {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const x = cloud.x + (i - 2) * cloud.size * 0.3;
                    const y = cloud.y + Math.sin(i) * cloud.size * 0.1;
                    const r = cloud.size * (0.5 + Math.sin(i) * 0.2);
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                }
                ctx.fill();
            });
        }

        // Draw animated ground
        function drawGround() {
            const groundY = canvas.height - ground.height;
            
            // Ground gradient
            const groundGradient = ctx.createLinearGradient(0, groundY, 0, canvas.height);
            groundGradient.addColorStop(0, '#8FBC8F');
            groundGradient.addColorStop(0.3, '#6B8E23');
            groundGradient.addColorStop(1, '#556B2F');
            
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, groundY, canvas.width, ground.height);
            
            // Ground texture
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            for (let x = ground.offset % 40; x < canvas.width; x += 40) {
                ctx.fillRect(x, groundY + 10, 2, ground.height - 20);
            }
            
            // Grass effect
            ctx.fillStyle = '#90EE90';
            for (let x = ground.offset % 20; x < canvas.width; x += 20) {
                ctx.fillRect(x, groundY, 1, 8);
                ctx.fillRect(x + 5, groundY, 1, 6);
                ctx.fillRect(x + 10, groundY, 1, 7);
            }
        }

        // Main draw function
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background elements
            drawBackground();
            drawPipes();
            drawGround();
            
            // Draw particles
            drawParticles();
            
            // Draw bird
            drawBird();

            // Draw game over screen
            if (gameState === 'gameOver') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Game Over text with glow
                ctx.shadowColor = '#FF6B6B';
                ctx.shadowBlur = 20;
                ctx.fillStyle = '#FF6B6B';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 60);
                
                ctx.shadowBlur = 10;
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 28px Arial';
                ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - 10);
                
                ctx.shadowBlur = 5;
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText('Press R or tap to restart', canvas.width / 2, canvas.height / 2 + 40);
                
                ctx.shadowBlur = 0;
                ctx.textAlign = 'left';
            }
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                // Resume audio context on first user interaction
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                jump();
            } else if (e.code === 'KeyR' && gameState === 'gameOver') {
                init();
            }
        });

        canvas.addEventListener('click', (e) => {
            e.preventDefault();
            // Resume audio context on first user interaction
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            jump();
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Resume audio context on first user interaction
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            if (gameState === 'gameOver') {
                init();
            } else {
                jump();
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Start game
        init();
        gameLoop();

        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:text/javascript;base64,c2VsZi5hZGRFdmVudExpc3RlbmVyKCdpbnN0YWxsJywgZXZlbnQgPT4gewogIGV2ZW50LndhaXRVbnRpbChzZWxmLnNraXBXYWl0aW5nKCkpOwp9KTsKCnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZhdGUnLCBldmVudCA9PiB7CiAgZXZlbnQud2FpdFVudGlsKHNlbGYuY2xpZW50cy5jbGFpbSgpKTsKfSk7CgpzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2ZldGNoJywgZXZlbnQgPT4gewogIGV2ZW50LnJlc3BvbmRXaXRoKGZldGNoKGV2ZW50LnJlcXVlc3QpKTsKfSk7')
                .then(() => console.log('Service Worker registered'))
                .catch(err => console.log('Service Worker registration failed'));
        }

        // PWA Install Prompt
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            deferredPrompt = e;
            showInstallButton();
        });

        function showInstallButton() {
            const installButton = document.createElement('button');
            installButton.textContent = 'üì± Install App';
            installButton.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
                color: white;
                border: none;
                padding: 10px 15px;
                border-radius: 20px;
                font-weight: bold;
                cursor: pointer;
                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                z-index: 1000;
            `;
            
            installButton.addEventListener('click', async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const result = await deferredPrompt.userChoice;
                    if (result.outcome === 'accepted') {
                        console.log('App installed');
                    }
                    deferredPrompt = null;
                    installButton.remove();
                }
            });
            
            document.body.appendChild(installButton);
        }
    </script>
</body>
</html>
